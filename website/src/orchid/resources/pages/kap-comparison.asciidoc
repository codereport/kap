= KAP for APL'ers
:experimental:

:toc:

== Introduction

KAP is very similar to APL in several aspects.
So much so that an APL'er may be convinced that it is a full APL.
If they do, they will be surprised when certain things does not behave the way they expect.
The purpose of this document is to explain how KAP works from the perspective of a developer who already knows APL.

The different features are listed here in no particular order.

== Differences between KAP and APL

=== Syntax

==== Multiline input

If the final character of a line is the backquote character, then the newline is ignored and parsing continues with the next one:

[source,kap]
----
a ← 1 2 3 `
    4 5 6
----

Note that lines cannot be broken in the middle of a symbol.
In other words, the newline is interpreted as a space.

==== Namespaces

Every symbol in KAP belongs to a namespace.
Unless changed, the default namespace after starting the KAP REPL is `default`.
The default namespace can be changed using the `use` keyword.
The default namespace is the namespace where new symbols are interned if they cannot be found in any of the other namespaces in the search path.
After starting, the only namespace in the searchpath is `kap` which is where all the standard symbols are located.
Other namespaces can also be included using the `import` statement.

Symbols in other namespaces can be specified by prefixing them with the name of the namespace followed by a colon, such as `unicode:toCodepoints`.

Symbols with an empty namespace, `:abc`, could also be specified as `keyword:foo`.
As keywords are the most common use of symbols, this namespace is assumed by default if no namespace is given.

=== Datatypes

==== Numbers

APL only supports floating point numbers.
In practice the actual implementation may use different types for optimisation.
For example Dyalog supports a large number of different datatypes, such as byte arrays or integer arrays.
The details are hidden from the programmer who don't have to be concerned with underlying implementation details.

KAP makes the difference between integers and floating point numbers more visible to the programmer.
If a number is specified with a period, it is a floating point number (64-bit double).
Otherwise it is a 64-bit integer.
Mathematical operations between integers usually gives integer results.
If an operation is performed between an integer and a floating point number, the integer is first converted to floating point before the operation is performed.

The real and imaginary components of complex numbers are always floating point.

==== Characters

All characters are UTF-32 codepoints.
The functions `unicode:toCodepoints` and `unicode:fromCodepoints` can be used to convert numbers to and from character values respectively.

Strings are specified using double quotes rather than single quotes in APL.
The reason for this is to make it clear that they work differently compared to APL.
In KAP, a single character string is simply `"a"`.
This is different compared to APL where a single-character string has a special case where it represents just the character.
In APL, to type a single-character string, one has to type `,'a'`.
To specify a single character in KAP, use the `@` symbol, followed by the character.
Thus, the following two lines both specify the same string:

[source,kap]
----
"abc"
@a @b @c
----

==== Symbols

Symbols are first-class objects in KAP.
They work similar to Lisp in that they are unique objects identified by their name.
Symbols in the `keyword` namespace are special in that they always evaluate to themselves and as such are useful for things like hash keys.
To obtain the symbol itself instead of its value, they are prefixed by a quote:

[source,kap]
----
a ← 'foo     ⍝ a now contains the symbol foo itself rather than the value of the variable
b ← :abc     ⍝ b contains the keyword foo, no need to use ' here
----

==== Hashtables

Hashtables are a separate datatypes in KAP.
They are immutable, and updating a hashtable returns a new instance with the requested change applied.

A hashtable is created using the function `map`.
It accepts either a 2-element array with the key and value of a single element, or a 2-dimensional array with 2 columns containing key/value pairs:

[source,kap]
----
⍝ Create a hashtable with a single element mapping foo to bar
a ← map "foo" "bar"

⍝ Create a hashtable with three elements:
b ← map 3 2 ⍴ `
    "foo" "value is a string" `
    "test" 1 `
    "test2" 2
----

=== Function declarations

APL has two ways of declaring functions, either tradfns or using dfns.
The former are global functions while the latter are local to the current scope.

==== Tradfn

The original method uses `∇` and declares a function that allows you to use flow control using `→`.
The following is an example of an APL tradfn:

[source,apl]
----
∇ R←A foo B
  ⎕←'This function returns 10 plus the sum of A and B'
  R←A+B
∇
----

KAP provides a similar form.
The corresponding version looks like this:

[source,kap]
----
∇ A foo B {
  io:println "This function returns 10 plus the sum of A and B"
  A+B
}
----

The main difference here are:

- The code is enclosed between `{` and `}`.
This is to make code blocks consistent across all uses.
- In tradfns the return value is assigned to a special variable.
In KAP, the function returns the last value that was evaluated.
- KAP does not support the use of goto for flow control (please see the separate section on flow control for alternative solutions).

Functions defined using this style are global, and after declaration they can be accessible from any part of a program.

==== Dfns style

Defining a dfn in KAP is similar to APL.
The only visible difference is the use of `⇐` instead of `←`.
The reason for this difference is because `⇐` is processed at parse time, while `←` represents a runtime assignment to a variable.
As these are vastly different types of operations, different symbols are used to represent these operations.

[source,kap]
----
foo ⇐ { ⍵+1 }
----

=== Parse-time vs. evaluation-time

In APL, a function declared using `←` takes effect immediately.
Thus, the following expression is valid in APL:

[source,apl]
----
a ← { b ⍵+10 }
b ← { ⍵+1 }
a 1  ⍝ This will print 12
----

The corresponding code in KAP will not work, becuase at the time where the definition of `a` happens, `b` is not yet declared and the following error will be displayed when `a` is called on the last line: `Variable not assigned: default:b`.
This error may seem confusing until one notes that when the first line was parsed, `b` was assumed to be a variable, and this variable indeed does not have a value.

This difference is important when coming from APL.
During parsing, KAP needs to know whether a symbol represents a function, an operator or a value.
Any undefined symbols are assumed to be values.
