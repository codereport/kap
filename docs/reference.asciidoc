= Kap reference
:experimental:

:toc:

== Introduction

The following document intends to list all functions and operators available in Kap.
The list is currently incomplete.

When describing arguments to dyadic calls, the left argument is referred to as `A` and the right argument as `B`.

== Syntax

=== Datatypes

Kap supports the following datatypes:

- Integer: `1234`, `¯456`, `0x12` (the `0x` prefix indicates the value is specified in hex)
- Floating point: `1.234`, `¯0.001`
- Rational: The result of dividing two integers: `(2÷7)`
- Complex: `1j7`, `2.8j1.2`.
Note that the real and imaginary parts are always floating point.
- Character: `@a`
- Map: Created using the `map` function
- Symbol: `'foo`, `'qw:bar`.
If the namespace name is blank, the symbol is placed in the `keyword` namespace: `:abcd`.
All keywords are self-evaluating.
- Array: An N-dimensional array of values, where each value is a primitive or another array

=== Character syntax

A character is a single Unicode codepoint.
The following forms are allowed:

- `@a` -- Any character is allowed, except backlash
- `@\LATIN_CAPTIAL_LETTER_B` -- Unicode name, spaces are replaced with underscore
- `@\u0397` -- Hex codepoint
- `@\n` -- Newline (codepoint U+000A)
- `@\r` -- CR (codepoint U+000D)
- `@\e` -- Esc
- `@\s` -- Space
- `@\t` -- Tab
- `@\0` -- Nul character

=== String syntax

Strings are single-dimensional arrays of characters, enclosed in double-quotes: `"foo test"`.

The following escape codes are allowed in a string:

- `\"` -- Double quote
- `\n` -- Newline
- `\r` -- CR

=== N-tuples

N-tuples, also simply called "`lists`", are primitive values that act as a container of zero or more values.
The explicit list syntax uses `;` to separate the elements.
List parsing has lower precedence than boolean operations as well as regular lists and function calls, which means that they usually have to be enclosed in parentheses.

`1;2;3;4` -- A list consisting of 4 elements. +
`1 + 2 ; 3 + 4 ; 5` -- a list consisting of the three values: `3`, `7`, and `5`.

=== Short-circuiting boolean operations

The names `and` and `or` are short-circuiting functions that act on the arguments true/false property.
For the purposes of these functions, the numeric value `0` is considered false, and any other value is true.

`io:println 2 and io:println 3` -- Evaluates to `3`, and will print both `2` and `3`. +
`io:println 1 or io:println 0` -- Evaluates to `1`, and will not print `0`.

Note that `and` and `or` has higher precendece than lists, but lower than regular lists and function calls.

== Syntactic elements

=== `⍝`: Comments

The `⍝` character indicates the start of a comment.
Everything until the next newline will be ignored.

=== `∇`: Function definition

The symbol `∇` is used to define global functions.
The general form is:

----
∇ header {
  body
}
----

The last evaluated form in `body` is returned from the function.

The `header` has the following possible forms:

- `name` -- Declare a function named `name`.
In `body`, the left argument is accessed using `⍺` and the right argument using `⍵`.
- `name x` -- The right argument is accessed using the name `x`.
The left argument is not accessible.
- `x name y` -- The left argument is accessed using the name `x`, and the right argument has the name `y`.
- `(a;b) name (d;e)` -- The left and right arguments are assumed to be n-tuples and are destructured prior to evaluating the body.
- `(a name) x` -- Monadic operator deriving a monadic function.
- `x (a name b) y` -- Dyadic operator deriving a dyadic function.

When declaring an operator, the function arguments are passed as function objects, and needs to be applied using the function application operation: `⍞`.

To declare a monadic function that returns the argument + 1:

----
∇ foo x {
  x+1
}
----

To declare an operator that adds 100 to the result of evaluating the function after adding 1 to the argument:

----
∇ (a foo) x {
  result ← ⍞a 1+x
  100 + result
}
----

=== `⇐`: Local function declaration

The symbol `⇐` is used to declare lexically scoped local functions.
It has the following general form:

----
foo ⇐ fn
----

Where `fn` can be any function as it appears in an expression.
This includes:

- Plain functions: `+`
- Function compositions: `+-`
- Dfns: `{ body }`
- Function reference applications: `⍞name`

The declared function has the normal lexical scope, which is the same as any variable declared in the same scope.
Local functions also has access to any variables visible within its scope.

=== `λ`: Create function reference

The `λ` symbol is used to create a function reference from a function.
The syntax is: `λ fn` where `fn` is any function as it appears in an expression.

The return value is a primitive value which behaves just like any primitive.
It can be passed to other functions, and be members of arrays.

When creating a function reference, the function captures any lexical bindings references from within the function.
These bindings remain valid even after the scope is exited.

To call a function from a function reference, use the apply symbol: `⍞`.
Please see the documentation for this symbol for more information.

=== `⍞`: Apply function from function reference

The `⍞` is used to call a function given its function reference.
It can take any of the following forms:

- `⍞ variable` -- Calls the function reference stored in variable `variable`.
- `⍞(expression)` -- `expresion` is evaluated to return a function reference which is subsequently called.

== Scalar functions

All scalar functions are evaluated in the same way.
For monadic invocations, the return value has the same shape as the argument, with the function being recursively applied to any non-primitive element in the input array.

For dyadic invocations, both arguments must have the same dimensions, or at least one of the arguments must be a scalar.
If the arguments have matching dimensions, the operation is applied pairwise.
If one of the arguments is a scalar, that scalar is applied together with each element in the other argument.

When performing scalar operation between different numeric types, the standard conversion rules apply, unless documented to do something different.
The rules are iterated from top to bottom, stopping after the first match:

- Any argument is complex - Complex
- Any argument is floating point - Floating point
- Any argument is rational - Rational
- Both arguments are integer - integer
- Both arguments are character - Character
- Raise an error

=== `+`: Add/Conjugate

==== Monadic: Conjugate

When called monadically, `+` performs the complex conjugate operation.
This operation reverses the sign of the imaginary part.
For real numbers, the operation simply returns the argument.

`+2` => `2`

==== Dyadic: Add

When called dyadically, this function adds the two arguments.
If one of the arguments is a character, the other argument must be a real number which is truncated to an integer and added to the Unicode value of the character, returning a new character.

`1+4` => `5` +
`0.0+5` => `5.0` +
`1j2 + 6j7` => `7.0J9.0` +
`@f + 1` => `@g`

=== `-`: Subtract/negate

==== Monadic: Negate

Negate the argument.

`-2` => `¯2` +
`-(¯2)` => `2` +
`-4j9` => `-4.0J-9.0`

==== Dyadic: Subtract

Subtract `B` from `A`.

`8-1` => `7`

Subtracting a character from another character will return the difference between taking the Unicode codepoint into consideration.
The most useful use of this is to subtract the nul symbol, `@\0`, from a character to obtain the Unicode codepoint as an integer: `@a - @\0` returns 97.

=== `×`: Multiply/angle

==== Monadic: Angle

For real values, return the values 1, 0 or -1 if the argument is positive, zero or negative respectively.
For complex arguments, return the angle of the point in complex space relative to the point at 0, or 0 if the value is at 0.

`×2` => `1`

==== Dyadic: Multiply

Multiply `A` with `B`.

=== `÷`: Divide/reciprocal

==== Monadic: Reciprocal

Return the reciprocal of the argument.

==== Dyadic: Divide

Divide `A` with `B`.

=== `|`: Mod/magnitude

==== Monadic: Magnitude

Returns the magnitude of the argument.
For real numbers, this is simply the absolute value.
For complex numbers, it's the length of the vector from the origin to the value.

`|3` => `3` +
`|¯4` => `4`

==== Dyadic: Modulo

Returns the value of `B` mod `A`.
Note that the order of the arguments is reversed compared to the similar function in most programming languages.

*TODO:* Describe the behaviour of complex mod

`2|5` => `1`

=== `⋆`: Power

==== Monadic: Power

Return e to the power of the argument.

==== Dyadic: Power with base

Return `A` to the power of `B`.

=== `⍟`: Log

==== Monadic: Natural logarithm

Return log(A).

==== Dyadic: Log base A

Return the base `A` logarithm of `B`.

=== `=`: Equals

==== Dyadic: Equals

Return 1 if `A` and `B` are equal, otherwise return 0.

Note that this function is a scalar function, meaning that arrays are compared element-wise.
To compare arrays for equality, use `≡`.

`10=10` => `1` +
`10=11` => `0` +
`1 2 3 = 1 3 4` => `1 0 0`

=== `≠`: Not equals

==== Dyadic: Not equals

Return 1 if `A` and `B` are not equal, otherwise return 0.

Note that this function is a scalar function, meaning that arrays are compared element-wise.
To compare arrays , use `≢`.

`10≠11` => `1` +
`3 3 4 4 ≠ 4 4 4 3` => `0 0 1 0`

=== `<`: Less than/increase rank

==== Monadic: Increase rank

When called monadically, this function performs the non-scalar operation "increase rank".
This function resizes the argument to a new array with a new dimension of size 1 added as an initial dimension.

The functionality is equivalent to `(1,⍴A) ⍴ A`

==== Dyadic: Less than

Return 1 if `A` is less than `B`.

Note that this function is a scalar function, meaning that arrays are compared element-wise.
To compare arrays, use `cmp`.

=== `>`: Greater than/decrease rank

==== Monadic: Increase rank

When called monadically, this function performs the non-scalar operation "decrease rank".
This function removes the major axis from the argument, and resizes the next axis to be the size of the first two axes multiplied together.

In other words, this function performs the following operation: `((×/2↑⍴A),2↓⍴A) ⍴ A` for arrays of 2 or more dimensions.
When called on arrays of 1 or 0 dimensions, this function returns its argument.

==== Dyadic: Greater than

Return 1 if `A` is less than `B`.

Note that this function is a scalar function, meaning that arrays are compared element-wise.
To compare arrays, use `cmp`.

=== `≤`: Less than or equal

==== Dyadic: Less than or equal

Return 1 if `A` is less than or equal to `B`.

Note that this function is a scalar function, meaning that arrays are compared element-wise.
To compare arrays, use `cmp`.

=== `≥`: Greater than or equal

==== Dyadic: Greater than or equal

Return 1 if `A` is greater than or equal to `B`.

Note that this function is a scalar function, meaning that arrays are compared element-wise.
To compare arrays, use `cmp`.

=== `∧`: Logical and

==== Dyadic: Logical and

Returns 1 if `A` and `B` are 1. If the arguments are not 0 or 1, raise an error.

`0∧1` => `0` +
`1∧0 1 0 0` => `0 1 0 0` +
`1∧@a` => Error: Invalid type +
`0∧3` => Error: Only 0 and 1 are allowed arguments

*Compatibility note:* APL uses ∧ to represent the least common multiple (LCM) operation.
This function is available in Kap as `math:lcm`.

=== `∨`: Logical or

==== Dyadic: Logical or

Returns 1 if either `A` or `B` are 1. If the arguments are not 0 or 1, raise an error.

`0∨0` => `0` +
`1∨1` => `1`

*Compatibility note:* APL uses ∨ to represent the greatest common divisor (GCD) operation.
This function is available in Kap as `math:gcd`.

=== `⍲`: Logical nand

==== Dyadic: Logical nand

Returns 0 if `A` and `B` are 1, otherwise return 1. This function is equivalent to `~A∧B`.

=== `⍱`: Logical nor

==== Dyadic: Logical nor

Returns 0 if either `A` or `B` are 1, otherwise return 1. This function is equivalent to `~A∨B`.

=== `∼`: Logical not/Without

==== Monadic: Logical not

Returns `1` if the argument is `0`, and vice versa.
If the argument is not 0 or 1, raise an error.

==== Dyadic: Without

This is a non-scalar function.
Returns `B` with all instances in `A` removed.

`1 2 3 4 5 6 ~ 3 6` => `1 2 4 5`

=== `√`: Square root

==== Monadic: Square root

Computes the square root of the argument.

==== Dyadic: Root of base

Computes the `A` root of `B`.

=== `⌊`: Min/Floor

==== Monadic: Floor

Returns the largest integer which is less than or equal to the argument.

*Compatibility note:* This function is not defined for complex numbers.
To access the APL-compatible complex floor operation, use `floorc`.

==== Dyadic: Min

Returns the smallest of `A` and `B`.

=== `⌈`: Max/Ceiling

==== Monadic: Ceiling

Returns the smallest integer which is greater than than or equal to the argument.

*Compatibility note:* This function is not defined for complex numbers.
To access the APL-compatible complex ceiling operation, use `ceilc`.

==== Dyadic: Max

Returns the largest of `A` and `B`.

=== `floorc`: Complex floor

==== Monadic: Complex floor

Computes the complex floor of the argument.

=== `ceilc`: Complex ceiling

==== Monadic: Complex ceiling

Computes the complex ceiling of the argument.

== Object comparison functions

=== `≡`: Compare equal/depth

==== Monadic: Depth

Returns the depth of the argument.
The depth is defined as being the largest number of recursively enclosed arrays.

`≡(1 2 3) (4 5 6) (7 8 (9 10))` => `3` +
`≡2` => `0`

==== Dyadic: Compare equals

Returns `1` if `A` and `B` are equal.
For arrays, this means that both arrays have the same shape, and each element in `A` also compares equal to the same element in `B`.

=== `≢`: Compare not equals/size of major axis

==== Monadic: Size of major axis

Return the size of the first dimension.
This is equivalent to `↑⍴A`.

`≢ 3` => 0 +
`≢ 1 2 3` => 3 +
`≢ 3 5 ⍴ ⍳15` => 3 +

==== Dyadic: Compare not equals

Returns `1` if `A` and `B` are not equal.

=== `cmp`: Compare

==== Dyadic: Compare

Compare `A` and `B`.
Returns `-1` if `A` is less than `B`, `0` if they are equal or `1` if `A` is greater than `B`.

== Structural functions

Structural functions are generally defined to be any function that does not obey the general roles of scalar functions.
Their return values may have a very different structure than its argument.

=== `⊢`: Identity/Right

==== Monadic: Identity

Returns the argument itself.

`⊢123` => `123`

==== Dyadic: Right

Returns the right argument

`1⊢2` => `2`

=== `⊣`: Identity/Left

==== Monadic: Identity

Returns the argument itself.

`⊢123` => `123`

==== Dyadic: Left

Returns the left argument

`1⊢2` => `1`

=== `⌷`: Index lookup

TODO

=== `⊂`: Enclose/Paritioned enclose

TODO

=== `⊃`: Disclose/Pick

==== Monadic: Disclose/Mix

If the argument is enclosed (i.e. an array of rank 0), the `⊃` function returns the array element:

----
    x ← ⊂"abc"
    ⊃ x
"abc"
----

If `⊃` is called on an array, it performs the standard APL mix operation.
If the lengths of the subarrays don't match, the resulting array will have the size of the largest subarray, with the shorter ones filled in with the default element of the array (normally 0).

----
    ⊃ (1 2 3) (6 7 8 9 10)
┌→─────────┐
↓1 2 3 0  0│
│6 7 8 9 10│
└──────────┘
----

==== Dyadic: Pick

Pick an element from `B` based on the specification in `A`.
The left argument can be seen as a chain of coordinates to find an element in a (possibly nested) array.
In its simplest form, it can be used to pick out a single element from a single-dimensional array:

----
    2 ⊃ 10 11 12
12
----

If more than one value is given, it is used to recursively find nested array elements:

----
    1 2 ⊃ (1 2 3) (4 5 6)
6
----

If the array being searched has more dimensions, one provides the full coordinates instead of just single elements:

----
    (1 0) 1 ⊃ 2 2 ⍴ (1 2 3) (4 5 6) (7 8 9) (10 11 12)
8
----

=== `,`: Concatenate/Ravel

TODO

=== `↑`: Take/Take first

TODO

=== `↓`: Drop/Drop first

TODO

=== `?`: Random

TODO

=== `⌽`: Rotate horizontally/Reverse horizontally

TODO

=== `⊖`: Rotate vertically/Reverse vertically

TODO

=== `⍉`: Transpose/Transpose by axis

TODO

=== `∊`: Member

==== Dyadic: Member

Returns an array of the same shape as `A`.
For each value in `A`, the corresponding value in the returned array is set to `1` if the value is found in `B`, otherwise, set it to `0`.

=== `⍷`: Find

TODO

=== `⍋`: Grade up

TODO

=== `⍒`: Grade down

TODO

=== `,`: Catenate/Ravel

TODO

=== `⍪`: Catenate first axis/Table

TODO

=== `⫽`: Select

=== `⍕`: Format

==== Monadic: Format

Returns a string representation of the argument.

=== `⍎`: Parse number

==== Monadic: Parse number

Given a string, attempt to parse it as a number.
Raises an error if the parsing failed.

=== `%`: Case

TODO

=== `⊆`: Partitioned enclose

TODO

=== `⊇`: Select

TODO

=== `∩`: Intersection

TODO

=== `∪`: Union

TODO

=== `⊤`: Decode

TODO

=== `⊥`: Encode

TODO

=== `⌹`: Matrix division

==== Monadic: Matrix inverse

Return the inverse of a matrix

==== Dyadic: Matrix division

Divide the matrix `A` with `B`.

== Operators

=== `¨`: For each

The given function is applied to the arguments and returns an array of the same shape as the input.

Assuming `FN` is a function:

`F¨ 1 2 3` is equivalent to `(F 1) (F 2) (F 3)`

`10 20 30 F¨ 1 2 3` is equivalent to: `(10 F 1) (20 F 2) (30 F 3)`.

*Lazy behaviour:* The result of `¨` is a lazy array.
The function will only be called when the underlying value is retrieved.
Note that the result is not cached, so if a result is retrieved more than once, the function will be called once for each time the value is read.
If multiple reads are expected it is recommended to collapse the array prior to reading it.

=== `/`: Reduce

==== Monadic: Reduce

Format: `F[axis]/ x` where `F` is a function, `x` is an array and `axis` is an optional <<Axis specifier,axis specifier>>.
The axis specifier defaults to the last axis if not specified.

If `x` is a one-dimensional array, the `/` operator acts as a simply left-reduction.
In other words, the following expression:

----
+/ 1 2 3 4
----

Results in the following computation (where the variables `tN` are temporary and not visible externally:

----
t0 ← 1+2
t1 ← t0+3
t1+4
----

When the argument has a higher dimension, the result array is reduced to the same shape, but with the selected axis removed.
For example, given a 3-dimensional array of shape `2 3 4`, the resulting array after reducing along axis 2 will be `2 3`.

When reducing a higher dimension array, the reduction always takes place along the selected axis, with actual operations performed as per the description above.

*Lazy behaviour:* The result of a reduction is a lazy array.
The computation will only happen when the result is requested.

==== Dyadic: Windowed reduce

TODO: Explain windowed reduce

=== `⌿`: Reduce leading axis/Windowed reduce leading axis

==== Monadic: Reduce leading axis

This function behaves the same as `/` with the only difference being that the axis specifier will default to 0 rather than the last axis.

==== Dyadic: Windowed reduce leading axis

This function behaves the same as `/` with the only difference being that the axis specifier will default to 0 rather than the last axis.

=== `⌻`: Outer product

Format: `x F⌻ y` where `F` is a dyadic function.

This operator derives a dyadic function that returns an array consisting of all combinations of the elements of the last axis of `x` with the elements of the leading axis of `y`.

For one-dimenaional arrays, this corresponds to a table mapping each element of `x` to each element of `y`:

----
    1 2 3 ,⌻ 1000 2000 3000
┌→─────────────────────────┐
↓┌→─────┐ ┌→─────┐ ┌→─────┐│
││1 1000│ │1 2000│ │1 3000││
│└──────┘ └──────┘ └──────┘│
│┌→─────┐ ┌→─────┐ ┌→─────┐│
││2 1000│ │2 2000│ │2 3000││
│└──────┘ └──────┘ └──────┘│
│┌→─────┐ ┌→─────┐ ┌→─────┐│
││3 1000│ │3 2000│ │3 3000││
│└──────┘ └──────┘ └──────┘│
└──────────────────────────┘
----

=== `.`: Inner product

TODO

=== `⍨`: Commute/duplicate

==== Monadic: Duplicate

Format: `F⍨ x`

Derives a monadic function that calls `F` dyadically with `x` as arguments.

`+⍨ 10` => `20`

==== Dyadic: Commute

Format `x F⍨ y`

Derives a function which calls the underlying function with he arguments reversed.

`10-⍨1` => `-9`

=== `⍣`: Power operator

TODO

=== `\`: Scan

TODO

=== `⍀`: Scan first axis

TODO

=== `⍤`: Rank operator

TODO

=== `∵`: Derive bitwise

Derives a version of the underlying function which performs its operation on the individual bits of an integer.
The following bitwise operations are implemented:

- `+`: xor
- `-`: xor
- `×`: and
- `∧`: and
- `∨`: or
- `⍲`: nand
- `⍱`: nor
- `~`: not
- `⌽`: logical shift

=== `∥`: Parallel

TODO

=== `˝`: Inverse

Derives the functional inverse of the argument function.
Generally, the inverse of a function is a function that satisfies the following: `F F˝ x` = `x`.
For dyadic invocations, the equivalence is: `x F x F˝ y` = `y`.

In plain language, the call `F˝ x` can be seen as answering the question: "`what value z can I pass to `F` such that `F z` returns `x`?`" Likewise, the dyadic call `x F˝ y` can be seen as answering the question: "`what value `z` can I pass to `x F z` that will return `y`?`"

The equivalence rule explained above is not strictly adhered to, but rather the implementations of the inverse functions are driven by practicality.
If a specific inverse makes more practical sense, then that is implemented even if the implementation isn't a strict inverse.

`10-˝3` => `7`

== Compositional operators

=== `∘`: Compose

- `x A∘B y` is evaluated as `x A (B y)`
- `A∘B y` is evaluated as `x A (B y)`

=== `⍛`: Inverse compose

- `x A⍛B y` is evaluated as `(A x) B y`
- `A⍛B y` is evaluated as `(A y) B y`

=== `⍥`: Over

The over operator derives a function which, when called dyadically, calls the right function on both arguments individually and then calls the left function on the results.
In other words, this operator can be thought of processing the arguments using A before acting on it using B.

- `x A⍥B y` is evaluated as `(B x) A (B y)`
- `A⍥B y` is evaluated as `A B y`

=== `⍢`: Structural under

TODO

=== `«` and `»`: Fork

The fork is specified using `«` and `»`.
It has the following form:

- `x A«B»C y` is evaluated as `(x A y) B (x C y)`
- `A«B»C y` is evaluated as `(A y) B (C y)`

=== Function chains

A sequence of two functions next to each other are executed in the same manner as a train in APL:

- `x (AB) y` is evaluated as `A x B y`

- `(AB) y` is evaluated as `A B y`

Since KAP does not implement APL-style forks, this expands to any number of functions in a train.
In other words:

- `x (ABCD) y` is evaluated as `A B C x D y`

=== Left-bound functions

A left-bound function derives a monadic function from a dyadic function by assigning a constant to the left argument.
For example, `2+` is a derived function that adds `2` to its argument.
This functionality is particularly useful in trains.
The following is a function that divides the argument by 2 and then adds 1: `1+2÷⍨`.
Example:

----
    A ⇐ 1+2÷⍨
    A 10
6
----

== Math functions (namespace `math`)

=== `math:sin`: Sine

==== Monadic: Sine

Compute the sine of the argument

=== `math:cos`: Cosine

==== Monadic: Cosine

Compute the sine of the argument

=== `math:tan`: Tangent

==== Monadic: Tangent

Compute the tangent of the argument.

=== `math:asin`: Arcsin

==== Monadic: Arcsin

Compute the arcsin of the argument

=== `math:acos`: Arccos

==== Monadic: Arccos

Compute the arccos of the argument

=== `math:atan`: Arctan

==== Monadic: Arctan

Compute the arctan of the argument.

=== `math:gcd`: GCD

==== Dyadic: GCD

Compute the greatest common divisor of `A` and `B`.

=== `math:lcm`: LCM

==== Dyadic: LCM

Compute the least common multiple of `A` and `B`.

=== `math:numerator`: Numerator

==== Monadic: Numerator

Returns the numerator of a rational number.
Raises an error if the argument is a floating point or complex.

=== `math:denominator`: Denominator

==== Monadic: Denominator

Returns the denominator of a rational number.
Raises an error if the argument is a floating point or complex.

== Map functions

The functions in this section are used to create, access and update map objects.
Maps are immutable, and any function that modifies the content returns a new objects with the changes applied while the original object remains unchanged.

=== `map`: Create a map

This function is called monadically with the initial content as argument.
The argument can either be a single-dimensional array with an even number of elements, or a two-dimension array with 2 columns.
In both cases, the key/value pairs are specified in an row-major interleaved form.

`map :foo 1 :bar 5` -- create a map with two elements

`map 4 2 ⍴ "key0" (1 2 3 4) "key1" "Some value" "key2" (2 2 ⍴ 1 2 3 4) "key3" "Abc"` -- create a map with 4 elements

=== `mapGet`: Read a value from a map

This function is called dyadically with `A` being the map and `B` being the key.
The corresponding value is returned, or `⍬` if the key was not found in the map.

=== `mapPut`: Update a map

This function is used to update a map.
It's called dyadically with `A` being the map, and `B` being a key/value definition as described in the documentation for `map`.
This function returns the updated map.

=== `mapRemove`: Remove elements from a map

This function removes keys from a map. `A` is the map to update, and `B` is an array consisting of a list of keys to remove.
This function returns the updated map.

=== `mapToArray`: Convert a map to an array

This function is called monadically with a map as argument.
It returns a two dimensional array with two columns, where the first column is the keys and the second column the values.

----
    m ← map "foo" 10 "bar" 20 "abcde" (1 2 3)
    mapToArray m
┌→──────────────┐
↓  "bar"      20│
│  "foo"      10│
│"abcde" ┌→────┐│
│        │1 2 3││
│        └─────┘│
└───────────────┘
----

=== `mapSize`: Return the size of a map

This function si called monadically with a map as it argument.
It returns the number of elements in the map.

----
    m ← map :a 11 :b 94 :c 4050 :d 91756
    mapSize m
4
----

== Flow control

=== `→`: Return

==== Monadic: Return

Return from the innermost function.
The argument is the value that will be returned.

==== Dyadic: Conditional return

If `A` is true, return `B` from the innermost function.

=== `if`: Conditional evaluation

Format: `if (expression) { thenStatement }`

Evaluate `expression`.
If true, evaluate `thenStatement` and return the result of its last form.
Otherwise, return `⍬`.

Format: `if (expression) { thenStatement } else { elseStatement }`

Evaluate `expression`.
If true, evaluate `thenStatement` and return the result of its last form.
Otherwise, evaluate `elseStatement` and return the result of its last form.

=== `when`: Multiple clause if

The `when` statement is used as an alternative to series of `if` and `else`.
The following sets `a` to be the value of some variable, or returns a message if all conditions failed.

----
a ← when {
  (b=1) { c }
  (b=2) { d }
  (b=3) { e }
  (1)   { "All comparisons were false" }
}
----

=== `while`: While loop

Format: `while (expression) { body }`

The `while` statement evaluates the body as long as `expression` is true.

----
i ← 0
while (i < 5) {
  io:println "Number: ",⍕i
  i ← i+1
}
----

=== `throw`: Throw exception

Exceptions are thrown using `throw`.
Exception have a type, represented by a symbol and some associated data.
The following example throws an exception of type `:foo` with data `"test"`:

----
:foo throw "test"
----

When called monadically, `throw` will throw an execption of type `:error`.

=== `catch`: Catch exceptions

The `catch` operator is used to perform some processing when an exception is thrown.
It has the following form: `F catch x`.

`x` must be either a one-dimensional array with an even number of elements, or a two-dimensional array with 2 columns.
The content must be pairs of values, where each pair is a tag, followed by a function reference.

The derived function first calls `F` with `⍬` as argument.
If the invocation of `F` does not throw an exception, its return value is returned.
If an exception was thrown, the tag is looked up in `x`, and if found, the corresponding function is called, with the left argument being the data that was passed to the `throw` call, and the right argument being the tag.
The return value from the handler is then returned.

== Regex

=== `regex:match`: Match string against regex

=== `regex:find`: Find matches in a string

=== `regex:finderror`: Find matches in string or raise error

=== `regex:create`: Compile regex

=== `regex:split`: Split by regex

=== `regex:replace`: Replace by regex

== JSON functions

=== `json:read`: Parse JSON from file

=== `json:readString`: Parse JSON from string

=== `json:writeString`: Write Kap objects as JSON

== Unicode functions

=== `unicode:toCodepoints`: Convert characters to codepoints

=== `unicode:fromCodepoints`: Convert codepoints to characters

=== `unicode:toGraphemes`: Split a string into graphemes

=== `unicode:toLower`: Convert a string to lower case

=== `unicode:toUpper`: Convert a string to upper case

=== `unicode:toNames`: Return Unicode names

== I/O functions

=== `io:read`: Read file

Format: `io:read name`

Read the content of the file `name` and return the lines in the file as an array of strings.

=== `io:print`: Print a value

Format: `io:print value`

Prints `value` to standard output.

=== `io:httpRequest`: HTTP GET

Performs an HTTP GET request and returns the result.

=== `io:httpPost`: HTTP POST

Performs an HTTP POST and returns the result.

=== `io:readdir`: Read contents of a directory

Format: `io:readdir path`, `format io:readdir path`

When called monadically, this function assumes the left argument is an empty array.

This function loads the contents of the directory at `path`, and returns a 2-dimensional array of results.
The first column is always the name of the directory entry, with the remaining columns decided by the `format` argument.

The `format` is a list of specifiers indicating what information should be included.
Currently the following formats are supported:

- `:size` -- the size of the file, or 0 if the entry is a directory
- `:type` -- the type of the entry, possible results are: `:file`, `:directory` or `:undefined`

== SQL

=== `sql:connect`: Connect to database

=== `sql:query`: Query database

=== `sql:update`: Perform update query

=== `sql:prepare`: Prepare statement

=== `sql:queryPrepared`: Perform query using prepared statement

=== `sql:updatePrepared`: Perform update query using prepared statement

== Graphics functions

=== `gui:create`: Create graphics window

=== `gui:draw`: Draw array

== Charting functions

=== `chart:bar`: Display bar chart

=== `chart:line`: Display line chart

== Definitions

=== Axis specifier

An axis specifier is integer value that specifies which axis of a multi-dimensional array to act on.
Axes are numbered from 0 to the dimensionality of the array - 1. For example, in a 2-dimensional array, axis 0 refers to the rows, while axis 1 refers to the columns.
