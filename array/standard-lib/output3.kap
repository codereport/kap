namespace("o3")

⍝ ┌┌┌→──┐
⍝ ↓↓↓0 1│
⍝ │││2 3│
⍝ ││├→──┤
⍝ ││↓4 5│
⍝ │││6 7│
⍝ │├├→──┤
⍝ │↓↓0 1│
⍝ │││2 3│
⍝ ││├→──┤
⍝ ││↓4 5│
⍝ │││6 7│
⍝ └└└───┘

isArray ⇐ 'array≡typeof
isChar ⇐ 'char≡typeof

isNumber ⇐ { (typeof ⍵) ∊ 'integer 'float 'complex 'rational }

⍝ Replace 0 with a space in the input array
zSpc ⇐ { (0≡¨⍵) % ⍵ @\s }

∇ isAplString (v) {
  (1≢≢⍴v) → 0
  ~0∊'char=typeof¨v
}

∇ isEnclosedArray {
  (0≠≢⍴⍵) → 0
  ⍵≢⊃⍵
}

∇ toHex {
  "0123456789ABCDEF" ⊇⍨ {⍵ ⫽⍨ ~×\0=⍵} (6 ⍴ 16) ⊤ ⍵
}

∇ renderChar ch {
  n ← ch-@\0
  ch ← if ((n ≥ 33) ∧ (n ≤ 126)) {
    @@ , ch
  } else {
    "@\\u" , toHex n
  }
  1 ¯1 ⍴ ch
}

∇ renderString {
  zSpc ⊃ (@\n≠)⍛⊂ @",⍵,@"
}

∇ alignCells (v) {
  if (2≢≢⍴v) { throw "alignCells requires the argument to have rank 2" }

  ⍝ The width of each column is the maximum width of any cell
  colWidths ← ⌈⌿ (↑↓⍴)¨v
  ⍝ Pad each cell to the correct width
  xAligned ← ((⍴v) ⍴ colWidths) {((≢⍵) (⍺-↑↓⍴⍵) ⍴ @\s),⍵}¨ v

  ⍝ Likewise for the heights
  rowHeights ← ⌈/ ≢¨xAligned
  yAligned ← (⍉ (⌽ ⍴ xAligned) ⍴ rowHeights) {⍵ ,[0] ((⍺-≢⍵) (↑↓⍴⍵)) ⍴ @\s}¨ xAligned
}

∇ renderArray v0 {
  aligned ← alignCells ¯1 (↑¯1↑⍴v0) ⍴ v0
  (nRows nCols) ← ⍴ aligned
  f ← ({⊂@│ , (⊃⍪/{⍺,@\s,⍵}/⍵) , @│}⍤2) (¯1 , (¯2↑⍴v0)) ⍴ aligned

  w ← ↑↓⍴↑f
  top ← 1 ¯1 ⍴ "┌→" , ((¯3+w) ⍴ @─) ,"┐"
  bottom ← 1 ¯1 ⍴ "└" , ((¯2+w) ⍴ @─) ,"┘"
  separator ← 1 ¯1 ⍴ "├→" , ((¯3+w) ⍴ @─) , "┤"
  res ← {top⍪⍵⍪bottom} ↑ ⍪⌿⍪ ¯1↓ , f ,[0.5] ⊂separator

  ⍝ To draw the layers to the left, first determine the number of layers and their sizes.
  ds ← ¯2↓⍴v0

  ⍝ Compute the number of layer indicators for each layer
  layerPos ← ×\⌽ ds

  makeVerticalLayer ⇐ {
    ⍝ Split content in groups of size ⍵, and compute height of each group
    sizes ← (+/≢¨⍤1) ¯1 ⍵ ⍴ f
    ⍝ Create a sequence of vertical bars according to the sizes,
    ⍝ and end with a split symbol. Finally remove the last instance.
    coverage ← ¯1+⍵
    centre ← ¯1↓↑,/ {( (⍵+coverage) ⍴ @│) , @├}¨ sizes
    ⍪ ↑ ,/ @┌ , centre , @└
  }

  ⍝ This should be avoidable
  if ((,0) ≡ ⍴ layerPos) {
    res
  } else {
    (↑,/ makeVerticalLayer¨ ⌽layerPos) , res
  }
}

∇ withBorder {
  (nRows nCols) ← ⍴⍵
  horizLine ← nCols ⍴ @─
  top ← "┌" , horizLine , "┐"
  bottom ← "└" , horizLine , "┘"
  top ⍪ (@│ , ⍵ , @│) ⍪ bottom
}

∇ format (v) { 1 }

∇ format (v) {
  v←v
  when {
    (isNumber v)        { 1 ¯1 ⍴ ⍕v }
    (isChar v)          { renderChar v }
    (isAplString v)     { renderString v }
    (isEnclosedArray v) { withBorder format ⊃v }
    (isArray v)         { renderArray format¨ v }
    (1)                 { throw "Unsupported type: ",⍕typeof v }
  }
}
